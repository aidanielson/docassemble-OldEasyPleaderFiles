---
include:
  - docassemble.playground1:2023-09-06_EP_Universal_Questions.yml
---
#features:
#  css: 2023-04-25_tony_test_with_expansion.css
---
metadata:
  title: Master Pleading Template
  short title: Polished legal documents. Zero hassle.
  time format: 'h:mm a'
---
imports:
  - re
---
mandatory: True
code: |
  version = 0
---
event: new_version
code: |
  version += 1
---
modules:
  - .POS_Builder
  - .ocr_processing
  - .gfrogs_dict
---
#################################### MANDATORY CODE BLOCK ####################################
---
mandatory: True
code: |
  set_parts(title='EasyPleader', logo='<img src="' + company_logo.url_for() + '" style="height: 28px; width: 115px;">')
  welcome_screen
  conduct_data_intake
  set_various_party_lists
  doc.type
  if doc.type == 'Letter':
  #  letter.enabled = True
    pass
  #else:
  #  pleading.enabled = True
  if doc.type == 'Separate Statement' or (doc.type == 'Letter' and doc.letter_type == 'disco_mc_ltr'):
    mc_ltr.propounder_or_responder
    if mc_ltr.propounder_or_responder == 'responder':
      pass
    choose_methods
    populate_methods
    # set propounding and responding parties and opponent choices
    methods.gather()
    # Run code to determine single discovery method or multiple methods
    mc_ltr.several_methods
    #if mc_ltr.several_methods == True:
      #xxxxx
    if doc.letter_type == 'disco_mc_ltr':
      mc_ltr.include_separate_statement
      #if mc_ltr.include_separate_statement:
      #  pleading.enabled = True
      mc_ltr.propose_call_or_meeting
      mc_ltr.response_deadline
      addressee
      set_letter_address_blocks
      #troubleshoot_letter_address_block
  if doc.type == 'Memorandum of Points & Authorities':
    memo_headings_lvl_1.gather()
    memo_heading_review
  if doc.type == 'Declaration':
    doc.declarant
    set_doc_declarant_unique_party
  if doc.type == 'Proof of Service':
    pick_server
    if pick_server != 'Me':
      server[0].name.first
    set_servees
    if not same_service:
      for servee in all_servees:
        servee.pick_service_methods
    else:
      same_service_method
    show_service_list
  if attach_exhibits:
    exhibits_yaml
  if doc.type not in ['Generic Pleading', 'Proposed Order', 'Proof of Service', 'Letter'] or not mc_ltr.include_separate_statement:
    set_doc_support_oppose_string
    doc.lm_proceeding_title
    doc.wants_proposed_title
  else:
    doc.title_full
  if doc.type != 'Letter' and not mc_ltr.include_separate_statement:
    doc.footer
    atty_info_in_caption
  if doc.has_hrg:
    hrg.date
  if doc.type != 'Proposed Order':
    sig_block_type
    sig_block_date_field
    if doc.sign:
      signature
  lead_filing_party
  court.short_name
  build_case_strings
  doc_download
  final_screen
---
################################### MAIN OBJECTS BLOCK ###################################
---
objects:
  - court: DAObject
  - case: DAObject
  - hrg: DAObject
  - doc: DAObject
  #- disco_propounded: DAObject
  - mc_ltr: DAObject
  #- mc_ltr.methods: DAList.using(object_type=Thing, elements=[mc_ltr.all_methods_propounded.true_values()], set_instance_name=True)
  - memo_headings_lvl_1: DAList.using(object_type=Thing, there_are_any=True, there_is_another=False)
  - dataloader: DataLoader.using(filename="2023-04-26_disco_blurbs.xlsx")
  - methods: DAList.using(object_type=Thing, there_are_any=True, there_is_another=False, complete_attribute='complete')
  - methods[i].response_deadline_extensions: DAList.using(object_type=Thing, there_is_another=False)
  - methods[i].responses: DAList.using(object_type=Thing, there_is_another=False, complete_attribute='complete')
  - methods[i].ncr: DAList.using(object_type=Thing, there_are_any=True, there_is_another=False, complete_attribute='complete')
  - combined_qa_list: DAList.using(object_type=Thing, there_are_any=True, there_is_another=False)
  #- letter: ALDocument.using(title='Meet & Confer Letter', filename='${ short_filename }', has_addendum=False)
  #- pleading: ALDocument.using(title='Pleading', filename='${ short_filename }', enabled=False, has_addendum=False)
  #- al_user_bundle: ALDocumentBundle.using(title="Forms to download", filename="${ short_filename }", elements=[letter, pleading])
  #- al_user_bundle: ALDocumentBundle.using(elements=[disco_attachment], filename="mcltr.docx", title="All forms to download for your records", enabled=True)
  #- disco_attachment: ALDocument.using(enabled=True, title="Meet & Confer Letter", filename="mcltr")
---
############################# ARRAY OBJECTS' 'COMPLETE' BLOCKS #############################
---
code: |
  methods[i].some_variable
  methods[i].ocr_responses
  if methods[i].name.text != 'Interrogatories' or methods[i].interrogatories_type == 'sprogs':
    methods[i].ocr_sprogs
  set_disco_parties_code
  methods[i].set_no
  set_disco_parties_short_ref
  methods[i].responses_service_method
  if methods[i].response_deadline_extensions.there_are_any:
    methods[i].response_deadline_extensions.gather()
    methods[i].response_deadline_extensions_review
  #use beginning/end numbers from above screen to populate the initial 'name.text' attributes of ALL requests/interrogatories, 'methods[i].responses'
  if methods[i].sprogs_ocrd.ready() and methods[i].responses_ocrd.ready():
    methods[i].troubleshoot_sprogs
    populate_qa_dict_from_sprogs
  else:
    waiting_screen
  if methods[i].name.text == 'Interrogatories' and methods[i].interrogatories_type == 'g_frogs':
    methods[i].frogs_propounded
    if methods[i].responses_ocrd.ready():
      ocr_completion_screen
    else:
      waiting_screen
    methods[i].clean_the_text
    methods[i].qa_dict = methods[i].extract_and_filter_qa_with_buffer(methods[i].gfrogs_served, methods[i].responses_clean_text)
    methods[i].error_sprogs = methods[i].scan_for_error_sprogs(methods[i].qa_dict)
    #troubleshoot_frogs
  set_combined_qa_list
  methods[i].sprogs_reviewed
  methods[i].pick_challenged_responses
  #use all selected checkboxes from 'methods[i].pick_challenged_responses' to initialize and populate the first '.name.text' attribute of each challenged request/interrogatory Thing object in the 'methods[i].ncr' DAList
  #select all applicable request/interrogatory numbers being contested/challenged
  set_challenged_responses_list
  sort_ncrs
  methods[i].ncr.gather()
  methods[i].complete = True
---
code: |
  methods[i].ncr[j].name.text
  methods[i].ncr[j].deficiencies
  if showifdef('methods[i].ncr[j].custom_critique'):
    methods[i].ncr[j].custom_critique_added_to_list
  methods[i].ncr[j].complete = True
---
######################################### LETTER #########################################
---
id: are you propounder or responder
question: Discovery Meet & Confer Letter
fields:
  - '**Are you the propounder or responder?**': mc_ltr.propounder_or_responder
    input type: radio
    choices:
      - We Propounded: propounder
      - We Responded: responder
---
id: discovery dispute resolution options
question: Discovery Dispute Resolution Options
fields:
  - '**Propose a call or meeting to confer?**': mc_ltr.propose_call_or_meeting
    datatype: checkboxes
    choices:
      - Phone call
      - Zoom call
      - In-person meeting/conference
    none of the above: False
  - '**To resolve the dispute, are you open to considering...**': mc_ltr.proposal_list
    datatype: checkboxes
    choices:
      - a stipulated protective order
      - narrowing scope or revising/clarifying language
      - stipulation to an informal discovery conference
      - reasonable extensions to respond based on legitimate need
      - appointment of a discovery referee
---
id: meet and confer letter options
question: Meet & Confer Letter Options
fields:
  - '**Subject Line**': mc_ltr.subject_line
    input type: area
    rows: 2
    default: "Initial Meet & Confer Attempt re ${ methods[0].responding_parties_short_ref }'s written discovery responses"
  - '**Include a Separate Statement of Items in Dispute?**': mc_ltr.include_separate_statement
    datatype: yesnoradio
  - note: |
      This is recommended because it separates the voluminous legal challenges to the responses from discussion of the other issues, such as deadline extensions, proposed resolution, and other meet-and-confer proceedings. It also shows you mean business.
---
id: follow up dates
question: Meet & Confer Timeline
fields:
  - '**Deadline to respond to this letter**': mc_ltr.response_deadline
    datatype: date
    grid: 3
  - '**Propose extension to MTC deadline?**': mc_ltr.request_to_extend_MTC_deadline
    datatype: yesnoradio
    grid: 2
  - '**Proposed MTC extension date**': mc_ltr.proposed_MTC_extension_deadline
    datatype: date
    grid: 3
    show if: mc_ltr.request_to_extend_MTC_deadline
  - '**Propose moving other litigation events/deadlines?**': mc_ltr.propose_other_event_calendaring
    datatype: yesnoradio
    grid: 
      width: 2
      start: True
right: |
  [BR][BR]Today is <span style="color: red;">**${ format_date(today(), format='EEEE, MMMM d, yyyy') }**</span>.[BR][BR]  
  45-Day MTC Deadlines:
  
  % for method in methods:
  * ${ method }: **${ format_date(method.mtc_deadline, format='EEEE, MMMM d, yyyy') }** (**${ nice_number(date_difference(starting=today(), ending=method.mtc_deadline).days) }** days)
  % endfor
---
id: letter service
reconsider: set_direct_contacts_sorted_list
question: Letter Service
fields:
  - '**Letter Addressee**': addressee
    datatype: object
    choices: |
      [lawyer if person.lawyers.there_are_any else person for person in parties + nonparties.complete_elements() for lawyer in (person.lawyers if person.lawyers.there_are_any else [person])]
  - '**Service Method**': addressee_service_methods
    datatype: checkboxes
    code: |
      list(service_method_dict.keys())
    none of the above: False
  - '**CC: anyone?**': include_cc_recipients
    datatype: yesnowide
    grid: 2
  - '**CC: Recipients**': letter_cc_recipients
    datatype: object_checkboxes
    choices: everyone_sorted_list
    none of the above: False
    minlength: 1
    show if: include_cc_recipients
---
################################# DISCOVERY DISPUTED ITEMS #################################
---
id: choose methods
question: The Discovery At Issue
fields:
  - '**What did you serve?**': choose_methods
    datatype: checkboxes
    code: |
      unique_values(dataloader, search_column="Method")
    none of the above: False
---
id: method info
question: '####${ methods[i].name.text }'
subquestion: |
  `${ json.dumps(methods[i].name.text) }`
fields:
  - Some Variable: methods[i].some_variable
  - '**Type of Interrogatories**': methods[i].interrogatories_type
    input type: radio
    choices:
      - General Form Interrogatories (DISC-001): g_frogs
      #- Unlawful Detainer Form Interrogatories (DISC-003): ud_frogs
      #- Economic Litigation Form Interrogatories (DISC-004): el_frogs
      #- Construction Litigation Form Interrogatories (DISC-005): cl_frogs
      #- Employment Law Form Interrogatories (DISC-002): emp_frogs
      - Special Interrogatories: sprogs
    show if:
      code: |
        methods[i].name.text == 'Interrogatories'
  - note: |
      **Upload the ${ methods[i] } *You Served***
    show if: 
      code: |
        methods[i].name.text != 'Interrogatories'
    js show if: |
      val('methods[i].interrogatories_type') === 'sprogs'
  - no label: methods[i].sprogs_file
    datatype: files
    js show if: |
      val('methods[i].interrogatories_type') === 'sprogs' || ${ json.dumps(methods[i].name.text) } !== 'Interrogatories'
  - note: |
      **Upload *the Responses***
    show if:
      code: |
        doc.type == 'Separate Statement' or doc.letter_type == 'disco_mc_ltr'
  - no label: methods[i].responses_file
    datatype: files
    show if:
      code: |
        doc.type == 'Separate Statement' or doc.letter_type == 'disco_mc_ltr'
validation code: |
  if methods[i].name.text == "Interrogatories":
    methods[i].short_unit_singular = 'interrogatory'
    methods[i].short_unit_plural = 'interrogatories'
    if methods[i].interrogatories_type == 'sprogs':
      methods[i].full_method = "Special Interrogatories"
      methods[i].formal_unit = 'special interrogatory'
    else:
      methods[i].full_method = "Form Interrogatories"
      methods[i].formal_unit = 'form interrogatory'
  elif methods[i].name.text == 'Requests for Admission':
    methods[i].full_method = methods[i].name.text
    methods[i].short_unit_singular = 'request'
    methods[i].short_unit_plural = 'requests'
    methods[i].formal_unit = 'request for admission'
  else:
    methods[i].full_method = methods[i].name.text
    methods[i].short_unit_singular = 'request'
    methods[i].short_unit_plural = 'requests'
    methods[i].formal_unit = 'request for production'
---
id: set disco parties code
code: |
  methods[i].show_the_propounding_parties_field = True
  methods[i].show_the_responding_parties_field = True
  methods[i].show_the_PP_collective_ref_field = 'show it'
  methods[i].show_the_RP_collective_ref_field = 'show it'
  if len(clients) == 1 and mc_ltr.propounder_or_responder == 'propounder':
    methods[i].propounding_parties = clients[0]
    methods[i].show_the_propounding_parties_field = False
    methods[i].show_the_PP_collective_ref_field = 'do not show'
    
  if len(clients) == 1 and mc_ltr.propounder_or_responder == 'responder':
      methods[i].responding_parties = clients[0]
      methods[i].show_the_responding_parties_field = False
      methods[i].show_the_RP_collective_ref_field = 'do not show'

  set_disco_parties_code = True
---
id: parties, set no, and range
question: Parties, Set No. & ${ capitalize(methods[i].short_unit_singular) } Numbers
fields:
  - '**Propounding Party(ies)**': methods[i].propounding_parties
    datatype: object_checkboxes
    choices: |
      clients if mc_ltr.propounder_or_responder == 'propounder' else parties_sorted_list
    none of the above: False
    show if:
      code: |
        methods[i].show_the_propounding_parties_field
  - '**Responding Party(ies)**': methods[i].responding_parties
    datatype: object_checkboxes
    choices: |
      clients if mc_ltr.propounder_or_responder == 'responder' else parties_sorted_list
    none of the above: False
    show if:
      code: |
        methods[i].show_the_responding_parties_field
  - '**Set Number**': methods[i].set_no
    input type: combobox
    choices: 
      - One
      - Two
      - Three
      - Four
      - Supplemental
  - '**Starting #:**': methods[i].start_range
    datatype: integer
    #label above field: True
    grid: 2
    show if: 
      code: |
        methods[i].name.text != 'Interrogatories' or methods[i].interrogatories_type == 'sprogs'
  - '**Ending #:**': methods[i].end_range
    datatype: integer
    #label above field: True
    grid: 
      width: 2
      label width: 3
    show if: 
      code: |
        methods[i].name.text != 'Interrogatories' or methods[i].interrogatories_type == 'sprogs'
  - '**Service Method**': methods[i].requests_service_method
    grid:
      width: 3
      label width: 3
    code: |
      list(service_method_dict.keys())
  - '**Service Date**': methods[i].requests_service_date
    datatype: date
    grid:
      width: 3
      label width: 3
validation code: |
  if showifdef('methods[i].start_range'):
    if methods[i].start_range > methods[i].end_range:
      validation_error('The Ending No. must be greater than the Starting No.', field='methods[i].end_range')
---
code: |
  if methods[i].propounding_parties is clients[0] or len(methods[i].propounding_parties) < 2:
    methods[i].propounding_parties_short_ref = methods[i].propounding_parties.short_name
  else:
    methods[i].propounding_parties_short_ref
    
  if methods[i].responding_parties is clients[0] or len(methods[i].responding_parties) < 2:
    methods[i].responding_parties_short_ref = methods[i].responding_parties.short_name
  else:
    methods[i].responding_parties_short_ref
    
  set_disco_parties_short_ref = True
---
id: propounder and responder collective ref 
question: Collective Reference
fields:
  - '**Collective Shorthand Reference to Propounders**': methods[i].propounding_parties_short_ref
    show if:
      code: |
        methods[i].show_the_PP_collective_ref_field == 'show it' and len(methods[i].propounding_parties) > 1
  - '**Collective Shorthand Reference to Responders**': methods[i].responding_parties_short_ref
    show if:
      code: |
        methods[i].show_the_RP_collective_ref_field == 'show it' and len(methods[i].responding_parties) > 1
---
id: responses service and nature
question: Responses to ${ methods[i] }
fields:
  - '**Responses Service Method**': methods[i].responses_service_method
    code: |
      list(service_method_dict.keys())
  - '**Responses Service Date**': methods[i].responses_service_date
    datatype: date
  - '**Was there an agreement to extend the response deadline?**': methods[i].response_deadline_extensions.there_are_any
    datatype: yesnoradio
  - '**How did they respond?**': methods[i].responses_type
    input type: radio
    choices: 
      - objections only
      - a hybrid mix of objections and substantive responses
      - substantive responses without objection
  - '**Were responses *verified*?**': methods[i].verified
    datatype: yesnoradio
    js show if: |
      val('methods[i].responses_type') != 'objections only'
  - '**Were responses untimely?**': methods[i].responses_untimely
    datatype: yesnoradio
---
id: discovery extensions history
question: "${ ordinal(j).capitalize() } Response Deadline Extension"
subquestion: |
  The initial response deadline was **${ methods[i].requests_service_date.plus(days=35) }**.
fields:
  - '**Number**': methods[i].response_deadline_extensions[j].name.text
    grid: 3
  - '**Date you <u>Granted</u> Extension**': methods[i].response_deadline_extensions[j].date_granted
    datatype: date
    grid: 
      width: 3
      label width: 3
  - '**<u>How</u> you Granted Extension**': methods[i].response_deadline_extensions[j].how_granted
    input type: combobox
    grid: 
      width: 3
      label width: 3
    choices:
      - Email Confirmation: email
      - Telephone Confirmation: phone
      - Letter Confirmation: letter
  - '***Old* Deadline**': methods[i].response_deadline_extensions[j].old_deadline
    datatype: date
    grid: 
      width: 3
      label width: 3
  - '***New* Deadline**': methods[i].response_deadline_extensions[j].new_deadline
    datatype: date
    grid: 
      width: 3
      label width: 3
---
id: review extension history
question: Response Deadline Extension History
subquestion: |
  ${ methods[i].response_deadline_extensions.table }
  ${ methods[i].response_deadline_extensions.add_action(label='Add Extension', color='warning') }
continue button field: methods[i].response_deadline_extensions_review
---
table: methods[i].response_deadline_extensions.table
rows: methods[i].response_deadline_extensions
columns:
  - Date Granted: row_item.date_granted
  - Old Deadline: row_item.old_deadline
  - New Deadline: row_item.new_deadline
  - Granted via: row_item.how_granted
edit:
  - row_item
allow reordering: True
---
id: pick propounded form rogs
question: Select the Form Interrogatories You Propounded
fields:
  - no label: methods[i].frogs_propounded
    datatype: checkboxes
    grid: 2
    code: get_gfrogs_dict_keys_list()
    none of the above: False
    all of the above: True
    default:
      code: |
        ['1.1', '2.1', '2.2', '2.5', '2.6', '2.7', '2.8', '2.9', '2.10']
validation code: |
  methods[i].gfrogs_served = methods[i].frogs_propounded.true_values().sort(key=lambda x: (int(x.split('.')[0]), int(x.split('.')[1]) if '.' in x else 0))
---
#id: display propounded gfrogs
#question: The GFROGS you served are
#subquestion: |
#  ${ get_formatted_values_by_keys(gfrogs_served) }
#continue button field: display_served_gfrogs
---
question: xxxxx
subquestion: |
  Your OCR completed!
continue button field: ocr_completion_screen
---
event: waiting_screen
question: |
  Please wait.
subquestion: |
  Your document is being processed.
  This may take several minutes.

  The text of your document will be
  shown on the screen when the
  processing is finished.
---
####################### FROGS CODE #####################################################
---
id: troubleshoot frogs
question: Troubleshoot Frogs
subquestion: |
  It is this:[BR]
  ${ methods[i].gfrogs_served }[BR]
  'repr methods[i].responses_ocrd.get().content' is:[BR][BR]
  ${ repr(methods[i].responses_ocrd.get().content) }
  [BR][BR]
  'methods[i].responses_clean_text is:[BR][BR]
  ${ methods[i].responses_clean_text }
  ${ methods[i].qa_dict }
continue button field: methods[i].troubleshoot_frogs
---
id: troubleshoot sprogs
question: Troubleshoot Sprogs
subquestion: |
  'methods[i].responses_ocrd.get().content' is:[BR][BR]
  **${ repr(methods[i].responses_ocrd.get().content) }**[BR][BR]
  'repr(found_answers)' is:[BR][BR]
  ${ repr(found_answers) }[BR][BR]
  and 'found_answers' is:[BR][BR]
  ${ found_answers }
  'methods[i].sprogs_ocrd.get().content' is:[BR][BR]
  **${ repr(methods[i].sprogs_ocrd.get().content) }**[BR][BR]
continue button field: methods[i].troubleshoot_sprogs
---
code: |
  start_number = methods[i].start_range
  end_number = methods[i].end_range

  def create_qa_dict(start_number, end_number):
    return {str(number): {'question': 'Question not detected/extracted', 'answer': 'Answer not detected/extracted'} for number in range(start_number, end_number + 1)}
    
  rogs_regex_capture_pattern = r'(?:special |general |form |general form )?interrogator(?:y|ies)\s{1,2}(?:no\.?:?|#|number)?\W*(\d{1,3}\.\d{1,2}|\d{1,3})[-:.;\s]+(\(\w.*?|.*?)(?=\n\d+\.\s+[A-Z]|\n\n[!@#%^&*)\/\\{}_\-=+\]|<>?.]|\s+(?:RESPONSE TO )?(?:GENERAL FORM |FORM |SPECIAL )?INTERROGATORY No[\d\., ]{1,7}[-:;.]+|\n{4,}|\.\n{3,})'
  
  rogs_responses_regex_capture_pattern = r'(?:response|answer|objection)s?\s{1,2}to\s{1,2}(?:special |general |form |general form )?interrogator(?:y|ies)\s{1,2}(?:no\.?:?|#|number)?\W*(\d{1,3}\.\d{1,2}|\d{1,3})[-:.;\s]+(\(\w.*?|.*?)(?=\n\d+\.\s+[A-Z]|\n\n[!@#%^&*)\/\\{}_\-=+\]|<>?.]|\s+(?:RESPONSE TO )(?:GENERAL FORM |FORM |SPECIAL )INTERROGATORY No[\d\., ]{1,7}[-:;.]+|\n{4,}|\.\n{3,})'
  
  rpd_regex_capture_pattern = r'(?:demand|request)s? (?:for |to )?(?:production |inspection )?(?:no\.?:?|#|number)?\W*(\d{1,3})[-:.;\s]+(.*?)(?=\n\d+\.\s+[A-Z]|["?!.\n](?:RESPONSE|REQUEST))'
  
  rpd_responses_regex_capture_pattern = r'(?:response|answer|objection) (?:to|for) (?:demand|request)s? (?:for |to )?(?:production |inspection )?(?:no\.?:?|#|number)?\W*(\d{1,3})[-:.;\s]+(.*?)(?=\n\d+\.\s+[A-Z]|["?!.\n](?:response |answer |objection )?(?:to |for )?(?:demand|request)s? (?:for |to )?(?:production |inspection )?(?:no\.?:?|#|number)?\W*\d{1,3}[-:.;\s]+)'
  
  def extract_text(content, pattern):
    '''
    Captures the responses to each individual interrogatory as separate text by running a regex findall pattern with capture groups against the entire text string returned from OCR.
    Args:
      content: variable containing the OCR'd text string to search against.
      pattern: the regex pattern with capture groups that is run against the content.
    Returns:
      a list of tuples, with the number of elements in each tuple equal to the number of capture groups in the regex match pattern.
    '''
    return re.findall(pattern, content, re.DOTALL | re.MULTILINE | re.IGNORECASE)
  
  def validate_content(found_questions, found_answers, start_number, end_number):
    total_expected = end_number - start_number + 1
    total_found = len(set(number for number, _ in found_questions + found_answers))
  
    # Check if the total found is significantly different from the total expected
    if abs(total_found - total_expected) > total_expected * 0.1: # 10% tolerance
      print(f"Warning: Mismatch detected. Expected {total_expected} questions/answers, but found {total_found}. Check the variables and content.")
  
    # Check if a large proportion of the question numbers don't match the range
    unexpected_numbers = [int(number) for number, _ in found_questions + found_answers if int(number) < start_number or int(number) > end_number]
    if len(unexpected_numbers) > total_expected * 0.1: # 10% tolerance
      print(f"Warning: {len(unexpected_numbers)} question/answer numbers are out of the expected range ({start_number} to {end_number}). Check the variables and content.")
  
  def populate_dictionary(found_items, qa_dict, start_number, item_type):
    '''
    Unpacks list of tuples returned by extract_text and assigns them to the keys (interrogatory number) and values (xxxxx) of the qa_dict, overwriting the placeholder values.
    Args: 
      - found_items (xxxx): xxxxx
      - qa_dict (dict): a dictionary prepopulated with placeholder text for each interrogatory in the range of sprogs served
      - start_number: (int) the beginning interrogatory number of the sprogs set
      - item_type: stand-in for the nested dictionary key ('question') and value ('answer')
    Returns:
      - nothing, but modifies the qa_dict by overwriting the placeholder values with the actual text sprogs and responses captured by regex from the ocr'd files
    '''
    for number, text in found_items:
      number = int(number)
      if str(number) in qa_dict:
        qa_dict[str(number)][item_type] = text.strip()
          
  qa_dict = create_qa_dict(start_number, end_number)
  
  def clean_ocrd_text(ocrd_text):
    regex_convert_extraneous_newlines_to_space = r'(?<=[a-z,])\n+(?=[A-Za-z])'
    regex_strip_whitespace_before_newline = r'[ \t]+\n'
    clean_text = re.sub(regex_strip_whitespace_before_newline, '\n', re.sub(regex_convert_extraneous_newlines_to_space, ' ', ocrd_text))
    return clean_text

  if methods[i].name.text == 'Interrogatories' and methods[i].interrogatories_type == 'sprogs':
    questions_regex_pattern = rogs_regex_capture_pattern
    responses_regex_pattern = rogs_responses_regex_capture_pattern
  elif methods[i].name.text == 'Requests for Admission':
    questions_regex_pattern = rogs_regex_capture_pattern
    responses_regex_pattern = rogs_responses_regex_capture_pattern
  else:
    questions_regex_pattern = rpd_regex_capture_pattern
    responses_regex_pattern = rpd_responses_regex_capture_pattern
  
  found_questions = extract_text(clean_ocrd_text(methods[i].sprogs_ocrd.get().content), questions_regex_pattern)
  found_answers = extract_text(clean_ocrd_text(methods[i].responses_ocrd.get().content), responses_regex_pattern)
  
  #validate_content(found_questions, found_answers, methods[i].start_range, methods[i].end_range) # Validation step
  
  populate_dictionary(found_questions, qa_dict, start_number, 'question')
  populate_dictionary(found_answers, qa_dict, start_number, 'answer')
  
  # Check the qa_dict for any question or answer that was not overwritten...error_sprogs will contain the numbers for which either the question or the answer was not detected/extracted
  error_sprogs = [number for number, item in qa_dict.items() if item['question'] == 'Question not detected/extracted' or item['answer'] == 'Answer not detected/extracted']
  
  populate_qa_dict_from_sprogs = True
---
id: build DAList out of keys and values from qa_dict for sprogs
code: |
  for key, value in qa_dict.items():
    combined_qa_list.appendObject()
    combined_qa_list[-1].name.text = f"{key}"
    combined_qa_list[-1].question = f"{value['question']}"
    combined_qa_list[-1].answer = f"{value['answer']}"
  set_combined_qa_list = True
---
id: pick all challenged responses
question: Choose Disputed Response Numbers
fields: 
  - no label: methods[i].pick_challenged_responses
    datatype: checkboxes
    code: |
      combined_qa_list
    all of the above: True
    none of the above: False
    minlength: 1
    grid: 2
---
code: |
  for number_picked in methods[i].pick_challenged_responses.true_values().sort(key=lambda y: float(y)):
    for sprog in combined_qa_list:
      if sprog.name.text == number_picked:
        methods[i].ncr.appendObject()
        methods[i].ncr[-1].name.text = sprog.name.text
        methods[i].ncr[-1].question = sprog.question
        methods[i].ncr[-1].answer = sprog.answer
        break
  set_challenged_responses_list = True
---
code: |
  methods[i].ncr.elements.sort(key=lambda y: float(y.name.text))
  sort_ncrs = True
---
id: explain noncompliant responses
question: |
  <span style="font-weight: bold; font-size: extra-large; background-color: lightblue; border: 2px solid black; border-radius: 4px; box-shadow: 1px 1px 1px gray; padding: 4px;">Challenge to ${ capitalize(methods[i].short_unit_singular) } # ${ methods[i].ncr[j] }</span>
subquestion: |
  <span style="font-weight: bold; font-size: small; background-color: lightblue; border: 2px solid black; border-radius: 5px; box-shadow: 1px 1px 1px gray; padding: 5px; margin-top: 6px; margin-bottom: 6px;">${ capitalize(methods[i].short_unit_singular) }:</span>
  <div style="line-height: 2%;">&nbsp;</div>
  ${ methods[i].ncr[j].question }
  <div style="line-height: 2%;">&nbsp;</div>
  <span style="font-weight: bold; font-size: small; background-color: lightblue; border: 2px solid black; border-radius: 5px; box-shadow: 1px 1px 1px gray; padding: 5px; margin-top: 6px; margin-bottom: 6px;">Response:</span>
  <div style="line-height: 2%;">&nbsp;</div>
  ${ methods[i].ncr[j].answer }[BR]
fields:
  - '**Choose all deficiencies**': methods[i].ncr[j].deficiencies
    datatype: multiselect
    grid: 
      width: 6
      label width: 5
    code: |
      [{"label": result["Label"], "group": result["Category"], "value": index} for index, result in dataloader._load_data()[dataloader._load_data()["Method"]==(methods[i].name.text)].iterrows()]
  - note: |
      [BR]**----Option: Type Custom Criticism----**
  - '**Add Criticism**': methods[i].ncr[j].add_custom_critique
    datatype: yesnowide
    grid: 4
  - note: |
      e.g., *The response is also noncompliant because...*     
  - '**Custom Criticism**': methods[i].ncr[j].custom_critique
    input type: area
    rows: 6
    show if: methods[i].ncr[j].add_custom_critique
script: |
  <script type="text/javascript">
    /* Need to activate the multiselect JavaScript on each input, after base64 encoding the name
     of the input (it is "methods[i].ncr[j].deficiencies" here) */  
     $(document).ready(function() {$("#${base64.b64encode(str('methods[i].ncr[j].deficiencies').encode()).decode().replace('=', '') } ").multiselect({enableCaseInsensitiveFiltering: true, inheritClass: true, enableClickableOptGroups: true, enableCollapsibleOptGroups: true, collapseOptGroupsByDefault: true});}); </script>
under: |
  % if defined('custom_critique_list'):
    **Custom Criticism (last three):**
    
    % for item in custom_critique_list[-3:]:
    * ${ item }
    % endfor
  % endif
---
id: create and maintain custom critique list for display
code: |
  if not defined('custom_critique_list'):
    custom_critique_list = []
  if methods[i].ncr[j].custom_critique:
    custom_critique_list.append(methods[i].ncr[j].custom_critique)
  methods[i].ncr[j].custom_critique_added_to_list = True
---
id: review sprogs
question: Review ${ methods[i].full_method }
subquestion: |
  % if error_sprogs:
    <span style="color: red;">**Alert: ${ methods[i].short_unit_singular.capitalize() } # ${ comma_and_list(error_sprogs) }** was/were not properly captured.</span>
  % endif
  ${ methods[i].sprogs_table }
continue button field: methods[i].sprogs_reviewed
---
table: methods[i].sprogs_table
rows: combined_qa_list
columns:
  - No.: bold(row_item)
  - Rog./Req.: row_item.question
  - Response: row_item.answer
edit:
  - question
---
id: question block for editing of sprogs
question: Revise/Confirm Interrogatory No. ${ combined_qa_list[i] }
fields:
  - '**Interrogatory**': combined_qa_list[i].question
    input type: area
    rows: 6
  - '**Response**': combined_qa_list[i].answer
    input type: area
    rows: 20
---
################################## DECLARATION ##################################
---
id: declaration info
depends on: version
question: Declaration Info
subquestion: |
  'json.dumps(author[0].name.full())' is: ${ json.dumps(author[0].name.full()) }.
fields:
  - '**Declarant Name**': doc.declarant
    datatype: object
    choices: everyone_sorted_list
  - '**Declarant Role**': doc.declarant_role
    choices: 
      - Author
      - Named Party
      - Other
    js hide if: |
      val('doc.declarant') === ${ json.dumps(author[0].name.full()) }
  - '**Declarant Role in the Case**': doc.declarant_capacity
    input type: area
    rows: 4
    show if:
      variable: doc.declarant_role
      is: 'Other'
    note: |
      Describe what relation or involvement the declarant has to the lawsuit.[BR]e.g., *I personally witnessed the vehicle collision involving the Plaintiff and Defendant that is the subject of this lawsuit...I inspected and evaluated the physical condition of the property that is the subject of this lawsuit...*
---
id: run code to determine if the declarant party role is unique
code: |
  selected_declarant_role = doc.declarant.party_role
  same_role_parties = [party for party in parties if party.party_role == selected_declarant_role]
  doc.declarant.unique_party = True if len(same_role_parties) < 2 else False
  set_doc_declarant_unique_party = True
---
id: set support oppose verbiage
code: |
  if doc.support_oppose == 'in support of':
    doc.support_oppose_string_for_body = f"{doc.support_oppose} {doc.lm_proceeding_movant.short_name}'s {doc.lm_proceeding_title} ({doc.lm_proceeding_title_short})"
    doc.support_oppose_string_for_title = f"{doc.support_oppose} {doc.lm_proceeding_movant.short_name}'s {doc.lm_proceeding_title}"
  if doc.support_oppose == 'in opposition to':
    doc.support_oppose_string_for_body= f"{doc.support_oppose} the {doc.lm_proceeding_title} ({doc.lm_proceeding_title_short}) brought by {doc.lm_proceeding_movant.party_role.lower()} {doc.lm_proceeding_movant.name.full()} ({doc.lm_proceeding_movant.short_name})"
    doc.support_oppose_string_for_title= f"{doc.support_oppose} {doc.lm_proceeding_movant.party_role} {doc.lm_proceeding_movant.name.full()}'s {doc.lm_proceeding_title}"
  if doc.support_oppose == 'in reply to':
    doc.support_oppose_string_for_body = f"{doc.support_oppose} the opposition of {doc.lm_opposition_party.party_role.lower()} {doc.lm_opposition_party} ({doc.lm_opposition_party.short_name}) to {doc.lm_proceeding_movant.short_name}'s {doc.lm_proceeding_title} ({doc.lm_proceeding_title_short})"
    doc.support_oppose_string_for_title = f"{doc.support_oppose} {doc.lm_opposition_party.party_role.lower()} {doc.lm_opposition_party}'s opposition to {doc.lm_proceeding_movant.short_name}'s {doc.lm_proceeding_title}"
  set_doc_support_oppose_string = True
---
############################# MEMORANDUM OF POINTS & AUTHORITIES #############################
---
id: memorandum point headings
depends on: version
question: Memo Point Headings
fields:
  - '**{ capitalize(ordinal(i)) } Point Heading**': memo_headings_lvl_1[i].name.text
    note: |
      If you don't want headings entered now, enter 'xxxxx' for one or more headings to have placeholders.[BR][BR]Use full sentence case, plus period at end.[BR][BR]Ex.: *Defendant's Responses to Plaintiff's Special Interrogatories Fails to Comply with the Civil Discovery Act.*[BR][BR]
---
id: memo point heading review
depends on: version
question: Review Memo Point Headings
subquestion: |
    **Point Headings**
    ${ memo_headings_lvl_1.table }
    ${ memo_headings_lvl_1.add_action(label='Add Heading', color='warning') }
continue button field: memo_heading_review
---
table: memo_headings_lvl_1.table
rows: memo_headings_lvl_1
columns:
  - Heading: |
      row_item
edit:
  - row_item
allow reordering: True
---
depends on: version
code: |
  if doc.type in ['Declaration', 'Proof of Service']:
    sig_block_type = 'declarant'
  elif doc.type == 'Proposed Order':
    sig_block_type = 'judge'
  else:
    sig_block_type = 'author'
---
############################# LAW & MOTION PROCEEDING INFO #############################
---
id: law and motion proceeding info
depends on: version
question: Law & Motion Proceeding Info
fields:
  - '**Title of Law & Motion/Litigation Proceeding**': doc.lm_proceeding_title
    note: |
      e.g., *Motion to Compel Further Responses to Special Interrogatories* 
  - '**Shorthand Reference to the Proceeding**': doc.lm_proceeding_title_short 
    input type: combobox
    choices:
      - Motion
      - Application
      - Request
      - OSC
      - Petition
      - Stipulation
  - '**Who is the movant?**': doc.lm_proceeding_movant
    datatype: object
    choices: all_parties_sorted_list
  - '**Does this document support/oppose/reply to the RFO?**': doc.support_oppose
    input type: radio
    choices:
      - in support of
      - in opposition to
      - in reply to
      - objecting to
      - regarding
  - '**Whose opposition does the reply address?**': doc.lm_opposition_party
    datatype: object
    choices: parties_sorted_list
    show if:
      variable: doc.support_oppose
      is: 'in reply to'
comment:
  revise the variable name 'all_served_parties' to the more accurate 'other_parties' or 'nonclient_parties'
---
############################### PLEADING DOCUMENT TITLE ###############################
---
id: non-lm document title
if: doc.type in ['Generic Pleading', 'Proposed Order', 'Proof of Service']
depends on: version
question: Non-LM Document Title
fields:
  - '**Document Title**': doc.custom_title_full
    input type: area
    rows: 3
    default: |
      ${doc.type if doc.type != 'Generic Pleading' else ''}
  - '**Short Title (optional)**': doc.custom_title_shorthand
    input type: area
    rows: 2
    required: False
---
id: lm document title
if: doc.type not in ['Generic Pleading', 'Proposed Order', 'Proof of Service']
depends on: version
question: Law & Motion Document Title
subquestion: |
  **Proposed Title:**[BR]**<span style="color:Red">${ doc.proposed_title }</span>**
fields:
  - '**Use Proposed Title**': doc.wants_proposed_title
    datatype: yesno
  - '**Custom Document Title**': doc.custom_title_full
    input type: area
    rows: 3
    default: ${ doc.proposed_title }
    disable if: doc.wants_proposed_title
    required: False
  - '**Short Title (optional)**': doc.custom_title_shorthand
    input type: area
    rows: 2
    required: False
############################### OPTIONAL DOCUMENT FEATURES ###############################
---
id: document feature options
depends on: version
question: Document Options
fields:
  - note: |
      [BOLDCENTER]--Notations on Caption Page--[BR]
  - '**Include Statutory Ref. Under Doc Title**': include_stat_callout
    datatype: yesno
  - '**Enter the statutory call-out text**': stat_callout
    show if: include_stat_callout
    note: |
      The contents of this box will appear on the caption page, one line beneath the document's title, in braces.[BR][BR]Ex: [CCP ยง 568, HSC ยง 17980.7]
  - '**Include "Concurrently filed with..." notice**': include_concurrently_filed_docs_notice
    datatype: yesno
  - '**Enter short titles of concurrently filed documents**': custom_entered_concurrently_filed_docs
    input type: area
    show if: include_concurrently_filed_docs_notice
    note: |
      Ex: *Memorandum of Points & Authorities; Declarations of XXXXX and YYYYY; Index of Exhibits; Request for Judicial Notice; [Proposed] Order*
  - note: |
      [BOLDCENTER]--Document Attachments & Acknowledgments--[BR]
  - '**Attach exhibits to this document**': attach_exhibits
    datatype: yesno
  - '**Attach notary acknowledgement**': include_notary_acknowledgment_form
    datatype: yesno
---
##################################### PROOF OF SERVICE #####################################
---
id: POS Server, Server Address, & Service Location
question: Who is serving the documents and from where
fields:
  - '**Title of document being served**': documents_served
  - '**Who is being served in this POS?**': choose_party_servees
    datatype: radio
    choices:
      - All Parties
      - Only Certain Parties
  - '**Choose parties being served**': party_servees
    datatype: object_checkboxes
    choices: parties_sorted_list
    show if:
      variable: choose_party_servees
      is: 'Only Certain Parties'
  - '**Nonparties are being served as well**': nonparties_being_served
    datatype: yesno
  - '**Choose nonparties being served**': nonparty_servees
    datatype: object_checkboxes
    choices: nonparties.complete_elements()
    show if: nonparties_being_served
  - '**Everyone is being served *the same way on the same day***': same_service
    datatype: yesno    
  - '**Who is serving the documents?**': pick_server
    datatype: radio
    choices:
      - Me
      - Someone Else
---
id: same service - choose service date and method
question: How is service being carried out?
fields:
  - '**Service Method**': same_service_method
    datatype: checkboxes
    code: |
      list(service_method_dict.keys())
  - '**Date of Service**': same_service_date
    datatype: date
---
id: different service - choose service date and method for each servee
generic object: ALPeopleList
question: "Service on ${ x[i] }: Method and Date"
fields:
  - '**Methods**': x[i].pick_service_methods
    datatype: checkboxes
    code: |
      list(service_method_dict.keys())
  - '**Date**': x[i].service_date
    datatype: date
validation code: |
  x[i].service_methods = x[i].pick_service_methods.true_values()
---
id: generate service list
question: Show POS
subquestion: |
  ${ build_POS(all_servees, documents_served, server_address) }
continue button field: show_service_list
---
########################################## CODE ##########################################
---
code: |
  mc_ltr.several_methods = True if len(methods) > 1 else False
---
code: |
  for method in choose_methods.true_values():
    methods.appendObject()
    methods[-1].name.text = f"{method}"
  populate_methods = True
---
code: |
  methods[i].mtc_deadline = methods[i].responses_service_date + date_interval(days=45)
---
code: |
  if showifdef('methods[i].interrogatories_type') and methods[i].interrogatories_type == 'g_frogs':
    methods[i].number_propounded = nice_number(len(methods[i].frogs_propounded.true_values()), use_word=True)
  else:
    methods[i].number_propounded = (nice_number(int(methods[i].end_range) - int(methods[i].start_range) + 1, use_word=True))
  
  #is_interrogatories = (getattr(methods[i], 'name.text', None) == 'Interrogatories')
  #is_sprogs = (getattr(methods[i], 'interrogatories_type', None) == 'sprogs')

  #if not is_interrogatories or is_sprogs:
  #  num = int(methods[i].end_range) - int(methods[i].start_range) + 1
  #  methods[i].number_propounded = nice_number(num, use_word=True)
  #else:
  #  methods[i].number_propounded = 'xxxx'

  #methods[i].number_propounded = (nice_number(int(methods[i].end_range) - int(methods[i].start_range) + 1, use_word=True)) if (methods[i] != 'Interrogatories' or methods[i].interrogatories_type == 'sprogs') else 'xxxx'
---
code: |
  methods[i].responses_ocrd = ocr_file_in_background(methods[i].responses_file, 'refresh', language='en', psm='3')
  methods[i].ocr_responses = True
---
code: |
  methods[i].sprogs_ocrd = ocr_file_in_background(methods[i].sprogs_file, 'refresh', language='en', psm='3')
  methods[i].ocr_sprogs = True
---
code: |
  # Clean text string returned from responses_ocrd.get().content
  methods[i].responses_clean_text = re.sub(r'(?<=[a-z,])\n(?=[A-Za-z])', ' ', re.sub(r'[ \t]+\n', '\n', methods[i].responses_ocrd.get().content))
  methods[i].clean_the_text = True
---
depends on: version
code: |
  if doc.type == 'Declaration':
    doc.proposed_title = doc.type + ' of ' + str(doc.declarant) + ' ' + title_case(doc.support_oppose_string_for_title)
  elif doc.type == 'Notice of Motion and Motion':
    doc.proposed_title = 'Notice of Motion and ' + doc.lm_proceeding_title
  elif doc.type in ['Memorandum of Points & Authorities', 'Request for Judicial Notice', 'Index of Exhibits', 'Separate Statement']:
    doc.proposed_title = doc.type + ' ' + title_case(doc.support_oppose_string_for_title)
  else:
    doc.proposed_title = doc.type + ' ' + title_case(doc.support_oppose_string_for_title)
---
depends on: version
code: |
  doc.title_full = doc.proposed_title if defined('doc.wants_proposed_title') else doc.custom_title_full
---
depends on: version
code: |
  if doc.custom_title_shorthand:
    doc.footer = doc.custom_title_shorthand
  else:
    doc.footer = doc.title_full
---
code: |
  atty_info_in_caption = True
---
id: determine servees
code: |
  if choose_party_servees == 'All Parties':
    all_servees = parties.complete_elements()
  else:
    all_servees = party_servees
  if nonparties_being_served:
    all_servees = all_servees.extend(nonparty_servees)
  set_servees = True
---
code: |
  server_address = author[0].address.on_one_line() if pick_server == 'Me' else '1234 Main Street, Honolulu, HI 20347'
---
id: full client recitation string
code: |
  client_string = comma_and_list(client.party_plus_whole_name for client in clients)
  client_plus_short_name_string = comma_and_list(client.party_plus_whole_name_plus_short for client in clients)
---
#################################### TROUBLESHOOTING CODE ####################################
---
question: troubleshoot methods
subquestion: |
  choose_methods.true_velues() is:[BR]
  ${ choose_methods.true_values() }
  Methods elements is: [BR]
  ${ methods.elements }
continue button field: troubleshoot_methods
---
code: |
  letter_address_block = f"{addressee.name.full()}"
  
  if showifdef('addressee.law_firm'):
    letter_address_block += f"\n{addressee.law_firm.upper()}"
  
  letter_address_block += f"\n{addressee.address.line_one()}\n{addressee.address.line_two()}"
  
  if 'Email' in addressee_service_methods:
    letter_address_block += f"\n{addressee.email}"
  
    if addressee.add_second_email:
      letter_address_block += f"\n{addressee.second_email}\n({addressee.second_email_recipient})"
  
  set_letter_address_blocks = True
---
id: troubleshoot letter address block
question: troubleshoot letter address block
subquestion: |
  The addressee is:[BR]
  ${ addressee } whose instanceName is: ${ addressee.instanceName }[BR]
  and whose address is ${ addressee.address.block() }
  The letter_address_block is:[BR]
  ${ letter_address_block }
continue button field: troubleshoot_letter_address_block
---
id: troubleshoot propounding parties
question: troubleshoot 
subquestion: |
  methods[0].propounding_parties is: [BR]
  ${ methods[0].propounding_parties }
continue button field: troubleshoot_propounding_parties
---
id: troubleshoot party instancenames1
question: troubleshoot party instancenames 1
subquestion: |
  This is 'parties'[BR]
  % for party in parties:
  ${ party } is ${ party.instanceName }[BR]
  % endfor
continue button field: troubleshoot_party_instancenames1
---
id: troubleshoot party instancenames2
question: troubleshoot party instancenames 2
subquestion: |
  This is 'parties'[BR]
  % for party in parties:
  ${ party } is ${ party.instanceName }[BR]
  % endfor
  This is 'parties_sorted_list'[BR]
  % for party in parties_sorted_list:
  ${ party } is ${ party.instanceName }[BR]
  % endfor
continue button field: troubleshoot_party_instancenames2
---
id: troubleshoot responding parties short ref
question: troubleshoot rp short ref
subquestion: |
  the short ref is[BR]
  % for method in methods:
  ${ method.responding_parties } whose short-ref is:${ method.responding_parties_short_ref }[BR]
  % endfor
continue button field: troubleshoot_short_ref